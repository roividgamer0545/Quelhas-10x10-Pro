<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è Quelhas: O Desafio Estrat√©gico</title>
    <style>
        /* --- ESTILOS GERAIS E DE TRANSI√á√ÉO (MANTIDOS) --- */
        body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            background-color: #f4f4f4; 
            margin: 20px; 
            color: #333;
        }
        
        /* CONTAINER PRINCIPAL DO JOGO */
        #game-container { 
            background-color: #fff; 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); 
            text-align: center;
            max-width: 95vw; 
            transition: opacity 1s ease-in-out; 
            opacity: 0; 
        }
        
        h1 {
            color: #3a86ff; 
            margin-bottom: 10px;
        }
        
        /* --- ESTILO DA TELA DE INTRODU√á√ÉO --- */
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #333;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            cursor: pointer;
            z-index: 1000;
            transition: opacity 0.5s ease-out;
        }

        #intro-screen h2 {
            font-size: 3em;
            margin-bottom: 15px;
            color: #ff9900; 
        }
        
        #intro-screen p {
            font-size: 1.2em;
            opacity: 0.7;
        }

        /* --- ESTILOS DO TABULEIRO E CONTROLES --- */

        #board {
            display: grid;
            grid-template-columns: repeat(10, 30px); 
            grid-template-rows: repeat(10, 30px);
            gap: 0; 
            margin: 20px auto;
            border: 2px solid #333; 
            background-color: #333; 
            width: fit-content;
            height: fit-content;
            overflow: hidden; 
        }

        .cell {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            
            background-color: #fff; 
            transition: background-color 0.2s, border 0.2s, box-shadow 0.2s;
            
            border: 1px solid black; 
        }
        
        .cell.odd { background-color: #d0d0d0; }
        .cell.even { background-color: #fff; }
        
        /* JOGADOR 1 (Vertical - Azul) */
        .cell.player1 { 
            background-color: #3a86ff; 
            color: white; 
            border: 1px solid #1c52b9;
        } 
        .cell.player1::before { content: "I"; }

        /* JOGADOR 2 (Horizontal - Laranja) */
        .cell.player2 { 
            background-color: #ff9900; 
            color: white; 
            border: 1px solid #cc7a00;
        } 
        .cell.player2::before { content: "‚Äî"; }

        /* C√©lula de In√≠cio Selecionada (vermelho) */
        .cell.selected { 
            border: 3px solid #e63946; 
            box-shadow: 0 0 5px #e63946;
        } 
        
        /* C√©lula de Destino V√°lida (verde √°gua) */
        .cell.valid-target { 
            border: 3px solid #2a9d8f !important; 
            box-shadow: 0 0 8px #2a9d8f;
            cursor: crosshair;
        }

        .cell:not(.player1):not(.player2):hover { 
            opacity: 0.8; 
            background-color: #a8dadc; 
        }
        
        /* Jogada do Bot (Verde Lim√£o) */
        .cell.bot-move {
            background-color: #70e000 !important; 
            border: 3px solid #38b000 !important;
            box-shadow: 0 0 8px #70e000;
        }

        #controls { 
            margin-top: 15px; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 15px; 
            align-items: center; 
            justify-content: center; 
            padding: 10px;
            border-bottom: 1px dashed #ccc;
        }
        button, select { 
            padding: 10px 15px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-weight: bold; 
            font-size: 1em;
            transition: background-color 0.1s;
        }
        #swap-btn { 
            background-color: #00b4d8; 
            color: white; 
        }
        #swap-btn:hover:not(:disabled) { 
            background-color: #008fa5; 
            cursor: pointer; 
        }
        #swap-btn:disabled { 
            background-color: #ccc; 
            color: #666; 
            cursor: not-allowed; 
        }
        #new-game-btn { 
            background-color: #4CAF50; 
            color: white;
        }
        #new-game-btn:hover { background-color: #45a049; }

        #status { 
            font-size: 1.4em; 
            margin: 15px 0; 
            min-height: 25px; 
            font-weight: bold; 
            color: #1d3557;
        }
        #log { 
            margin-top: 15px; 
            text-align: left; 
            padding: 10px; 
            border: 1px solid #ccc; 
            width: 90%; 
            max-width: 450px; 
            max-height: 120px; 
            overflow-y: auto; 
            background-color: #fafafa; 
            border-radius: 6px; 
            font-size: 0.9em; 
            line-height: 1.4;
        }
        #log div { border-bottom: 1px dotted #eee; padding: 2px 0; }
        #log div:last-child { border-bottom: none; }

        /* --- ESTILOS PARA AS REGRAS (Revisado) --- */
        #rules-section {
            text-align: left;
            margin-top: 25px;
            padding: 15px;
            background-color: #f0f8ff; 
            border: 1px solid #a8dadc;
            border-radius: 8px;
            max-width: 600px;
        }
        #rules-section h3 {
            color: #1d3557; 
            border-bottom: 2px solid #a8dadc;
            padding-bottom: 5px;
            margin-top: 0;
        }
        #rules-section strong {
            color: #e63946; 
        }
        .rule-point {
            margin-bottom: 8px;
            font-size: 0.95em;
        }
    </style>
</head>
<body>
    
    <div id="intro-screen" onclick="showGame()">
        <h2>‚öîÔ∏è Quelhas: O Desafio Estrat√©gico</h2>
        <p>Clique em qualquer lugar para come√ßar...</p>
        <p style="margin-top: 30px; font-size: 0.9em; color: #a0a0a0;">(10x10 com Regra da Troca e IA Mestre)</p>
    </div>

    <div id="game-container">
        <h1>Quelhas: O Desafio Estrat√©gico</h1>
        
        <div id="controls">
 
            <label for="game-mode">Modo de Jogo:</label>
            <select id="game-mode" onchange="resetGame()">
                <option value="HvsH" selected>Humano vs. Humano</option>
                <option value="HvsB">Humano (J1) vs. Bot (J2)</option>
                <option value="BvsH">Bot (J1) vs. Humano (J2)</option>
           
  </select>

            <label for="difficulty">N√≠vel do Bot:</label>
            <select id="difficulty" onchange="resetGame()">
                <option value="random">1 - Aleat√≥rio</option>
                <option value="greedy">2 - Gulosa (Mis√®re)</option>
                <option value="minimax_p1">3 - Avan√ßado (Minimax Prof. 1)</option>
        
         <option value="minimax_p2" selected>4 - Mestre (Minimax Prof. 2 - Estrat√©gico)</option>
            </select>
            
            <button id="swap-btn" onclick="triggerSwapRule()" disabled>Trocar Lados</button>
            <button id="new-game-btn" onclick="resetGame()">Novo Jogo</button>
        </div>
        
        <div id="status"></div>

   
      <div id="board"></div>

        <div id="log"></div>
        
        <div id="rules-section">
            <h3>üìñ Regras do Jogo</h3>
            <div class="rule-point">1. **Objetivo (Vit√≥ria Invertida - Mis√®re):** O objetivo √© **N√ÉO** ser o √∫ltimo jogador a conseguir fazer um movimento. O jogador que **n√£o consegue fazer uma jogada** (fica bloqueado) √© o **VENCEDOR**.</div>
            <div class="rule-point">2. **Movimento:** Os jogadores preenchem um conjunto de c√©lulas vazias **cont√≠guas** (em linha reta) na sua dire√ß√£o designada. O movimento deve ter um comprimento **m√≠nimo de 2 c√©lulas**.</div>
            <div class="rule-point">3. **Orienta√ß√µes Iniciais:** O **Jogador 1** joga **Verticalmente** (colunas) e o **Jogador 2** joga **Horizontalmente** (linhas).</div>
            <div class="rule-point">4. **Regra da Troca:** Ap√≥s o **primeiro movimento** do Jogador 1, o **Jogador 2** pode optar por **"Trocar Lados"**. Se a troca for feita, as orienta√ß√µes invertem-se (J1 fica Horizontal, J2 fica Vertical) e o J1 joga novamente.</div>
        </div>
        </div>

    <script>
        // --- CONSTANTES & VARI√ÅVEIS GLOBAIS ---
        const ROWS = 10;
        const COLS = 10;
        const PLAYER1 = 1;¬†
        const PLAYER2 = 2;¬†
        
        // Valores de Score Extremos (Ajustado para o Minimax Mis√®re)
        const SCORE_WIN = 10000000; 
        const SCORE_LOSS = -10000000;
        
        const MIN_LENGTH_FOR_BOT_SWAP = 4; // Esta constante n√£o √© mais usada para o check, mas mantida por clareza.
        const BOT_ANIMATION_DELAY_MS = 800; 
        
        const gameContainerEl = document.getElementById('game-container');
        const introScreenEl = document.getElementById('intro-screen');
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        const swapBtn = document.getElementById('swap-btn');
        
        const difficultyDepths = {
            'minimax_p1': 1,
            'minimax_p2': 2
        };

        let board = [];
        let currentPlayer = PLAYER1;
        let selectedCell = null;
        let gameActive = false;
        let sidesSwapped = false;
        let firstMoveDone = false;
        let swapAvailable = false; 
        
        let memoizationTable = {};

        // --- FUN√á√ÉO PARA MOSTRAR O JOGO ---
        function showGame() {
            introScreenEl.style.opacity = '0';
            setTimeout(() => {
                introScreenEl.style.display = 'none';
                gameContainerEl.style.opacity = '1'; 
                resetGame(); 
            }, 500);
        }


        // --- FUN√á√ïES DE L√ìGICA E UTILIDADE ---

        function coordsToIdx(r, c) { return r * COLS + c;
        }
        function idxToCoords(idx) { return { r: Math.floor(idx / COLS), c: idx % COLS };
        }
        
        function getPlayerOrientation(player) {
            if (sidesSwapped) { 
                return player === PLAYER1 ? 'Horizontal' : 'Vertical'; 
            }
            return player === PLAYER1 ? 'Vertical' : 'Horizontal';
        }

        function isCurrentPlayerBot() {
            const mode = document.getElementById('game-mode').value;
            return (mode === 'HvsB' && currentPlayer === PLAYER2) || (mode === 'BvsH' && currentPlayer === PLAYER1);
        }

        function getBotPlayer() {
            const mode = document.getElementById('game-mode').value;
            if (mode === 'HvsB') return PLAYER2;
            if (mode === 'BvsH') return PLAYER1;
            return 0;
        }
        
        function log(message) {
            logEl.innerHTML = `<div>${message}</div>` + logEl.innerHTML;
            while (logEl.children.length > 20) {
                logEl.removeChild(logEl.lastChild);
            }
        }

        function resetGame() {
            board = Array(ROWS * COLS).fill(0);
            currentPlayer = PLAYER1;
            selectedCell = null;
            gameActive = true;
            sidesSwapped = false;
            firstMoveDone = false;
            swapAvailable = false;
            swapBtn.disabled = true;
            memoizationTable = {};¬†
            logEl.innerHTML = '';
            
            renderBoard();
            updateStatus();
            log('--- Novo Jogo Iniciado (Mis√®re: Perde o √öltimo) ---');
            if (getBotPlayer() === PLAYER1) {
                makeBotMove();
            }
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            for (let i = 0; i < ROWS * COLS; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                
                const { r, c } = idxToCoords(i);
                if ((r + c) % 2 === 0) { cell.classList.add('even'); } 
                else { cell.classList.add('odd'); }
                
                if (board[i] === PLAYER1) { cell.classList.add('player1'); }
                else if (board[i] === PLAYER2) { cell.classList.add('player2'); }
                
                if (i === selectedCell) { cell.classList.add('selected'); }
                
                cell.dataset.index = i;
                cell.onclick = handleCellClick;
                boardEl.appendChild(cell);
            }
            if (selectedCell !== null) {
                highlightValidTargets(selectedCell);
            }
        }
        
        function updateStatus(isBotThinking = false) {
            const orientation = getPlayerOrientation(currentPlayer);
            let statusText = `Vez: Jogador ${currentPlayer} (${orientation})`;

            if (isCurrentPlayerBot()) {
                const botPlayer = getBotPlayer();
                statusText = `Vez: Bot (J${botPlayer}, ${orientation})`;
                if (isBotThinking) {
                    statusText += ` [A Calcular...]`;
                }
            }
            
            if (swapAvailable) {
                const j2Orientation = getPlayerOrientation(PLAYER2);
                statusText = `Decis√£o de Troca: Jogador 2 (${j2Orientation}) pode jogar ou **TROCAR LADOS**!`;
            }

            statusEl.innerText = statusText;
        }

        function clearHighlights() {
            Array.from(boardEl.children).forEach(cell => {
                cell.classList.remove('selected');
                cell.classList.remove('valid-target');
            });
        }
        
        function highlightValidTargets(startIdx) {
            const orientation = getPlayerOrientation(currentPlayer);
            const isVertical = orientation === 'Vertical';
            const { r: r1, c: c1 } = idxToCoords(startIdx);
            
            const cellElements = Array.from(boardEl.children);
            const checkAndHighlight = (r, c) => {
                const idx = coordsToIdx(r, c);
                if (isMoveValidPath(startIdx, idx)) { 
                    cellElements[idx].classList.add('valid-target');
                }
            };

            // Dire√ß√£o Positiva (Baixo/Direita)
            if (isVertical) {
                for (let r = r1 + 1; r < ROWS; r++) { 
                    if (board[coordsToIdx(r, c1)] !== 0) break;
                    checkAndHighlight(r, c1);
                }
            } else { 
                for (let c = c1 + 1; c < COLS; c++) { 
                    if (board[coordsToIdx(r1, c)] !== 0) break;
                    checkAndHighlight(r1, c);
                }
            }
            
            // Dire√ß√£o Negativa (Cima/Esquerda)
            if (isVertical) {
                for (let r = r1 - 1; r >= 0; r--) { 
                    if (board[coordsToIdx(r, c1)] !== 0) break;
                    checkAndHighlight(r, c1);
                }
            } else { 
                for (let c = c1 - 1; c >= 0; c--) { 
                    if (board[coordsToIdx(r1, c)] !== 0) break;
                    checkAndHighlight(r1, c);
                }
            }
            
        }

        function isMoveValidPath(startIdx, endIdx) {
            const { r: r1, c: c1 } = idxToCoords(startIdx);
            const { r: r2, c: c2 } = idxToCoords(endIdx);
            const orientation = getPlayerOrientation(currentPlayer);
            let isVertical = r1 !== r2 && c1 === c2;
            let isHorizontal = r1 === r2 && c1 !== c2;
            
            if (r1 === r2 && c1 === c2) return false;
            if (r1 !== r2 && c1 !== c2) return false; 
            
            if (orientation === 'Vertical' && !isVertical) return false;
            if (orientation === 'Horizontal' && !isHorizontal) return false;
            
            if (board[endIdx] !== 0) return false;

            let moveLength = isVertical ? Math.abs(r1 - r2) + 1 : Math.abs(c1 - c2) + 1;

            if (moveLength < 2) return false;
            
            // Verifica se h√° pe√ßas a bloquear o caminho (todas as c√©lulas no caminho devem ser vazias)
            if (isVertical) {
                let startR = Math.min(r1, r2);
                let endR = Math.max(r1, r2);
                for (let r = startR; r <= endR; r++) {
                    const idx = coordsToIdx(r, c1);
                    if (board[idx] !== 0) return false; 
                }
            } else {¬†
                let startC = Math.min(c1, c2);
                let endC = Math.max(c1, c2);
                for (let c = startC; c <= endC; c++) {
                    const idx = coordsToIdx(r1, c);
                    if (board[idx] !== 0) return false;
                }
            }
            return true;
        }

        function handleCellClick(event) {
            if (!gameActive) return;
            const isBotTurn = isCurrentPlayerBot();
            
            // Se for turno do Bot E a troca n√£o estiver dispon√≠vel (BvsH), bloqueia.
            // Se for Humano vs. Humano (HvsH), isBotTurn √© false, permitindo sempre o clique.
            if (isBotTurn && !swapAvailable) return; 

            const clickedIdx = parseInt(event.target.dataset.index);
            // C√©lula vazia?
            if (board[clickedIdx] !== 0) { 
                selectedCell = null;
                clearHighlights();
                renderBoard(); 
                return; 
            }

            if (selectedCell === null) {
                selectedCell = clickedIdx;
                event.target.classList.add('selected'); 
                highlightValidTargets(selectedCell);
                
            } else {
                const startIdx = selectedCell;
                const endIdx = clickedIdx;
                
                const { r: r1, c: c1 } = idxToCoords(startIdx);
                const { r: r2, c: c2 } = idxToCoords(endIdx);
                const isVertical = c1 === c2;
                let moveLength = isVertical ? Math.abs(r1 - r2) + 1 : Math.abs(c1 - c2) + 1;
                
                if (moveLength < 2) {
                    log('Jogada inv√°lida: O movimento deve ter no m√≠nimo 2 c√©lulas.');
                    selectedCell = null; 
                    clearHighlights();
                    renderBoard();
                    return;
                }

                if (tryMove(startIdx, endIdx)) {
                    log(`J${currentPlayer} (${getPlayerOrientation(currentPlayer)}) jogou.`);
                    
                    clearHighlights();
                    afterMove(currentPlayer, moveLength); 
                } else {
                    log('Jogada inv√°lida! Tente novamente.');
                }
                selectedCell = null; 
                clearHighlights();
            }
            renderBoard();
        }

        function tryMove(startIdx, endIdx) {
            const { r: r1, c: c1 } = idxToCoords(startIdx);
            const { r: r2, c: c2 } = idxToCoords(endIdx);
            const orientation = getPlayerOrientation(currentPlayer);
            let isVertical = r1 !== r2 && c1 === c2;
            let isHorizontal = r1 === r2 && c1 !== c2;
            if (r1 !== r2 && c1 !== c2) return false; 
            if (r1 === r2 && c1 === c2) return false;
            if (orientation === 'Vertical' && !isVertical) return false;
            if (orientation === 'Horizontal' && !isHorizontal) return false;
            
            let cellsToFill = [];
            
            if (isVertical) {
                let startR = Math.min(r1, r2);
                let endR = Math.max(r1, r2);
                for (let r = startR; r <= endR; r++) {
                    const idx = coordsToIdx(r, c1);
                    if (board[idx] !== 0) return false; 
                    cellsToFill.push(idx);
                }
            } else {¬†
                let startC = Math.min(c1, c2);
                let endC = Math.max(c1, c2);
                for (let c = startC; c <= endC; c++) {
                    const idx = coordsToIdx(r1, c);
                    if (board[idx] !== 0) return false; 
                    cellsToFill.push(idx);
                }
            }
            
            if (cellsToFill.length < 2) return false;
            for (const idx of cellsToFill) { board[idx] = currentPlayer; }
            return true;
        }

        // --- CORRE√á√ÉO: REGRA DA TROCA APLICA-SE SEMPRE NO PRIMEIRO MOVIMENTO ---
        function isSwapApplicable(lastPlayer, moveLength) {
            // A troca s√≥ √© aplic√°vel se J1 fez o primeiro movimento e o jogo ainda n√£o terminou/trocou.
            if (lastPlayer !== PLAYER1 || firstMoveDone || sidesSwapped) return false;
            // A regra aplica-se a qualquer movimento v√°lido (m√≠nimo de 2).
            return moveLength >= 2; 
        }
        
        function afterMove(lastPlayer, moveLength) {
            
            // 1. VERIFICA√á√ÉO DA REGRA DA TROCA
            if (lastPlayer === PLAYER1 && !firstMoveDone) {
       
                const swapApplies = isSwapApplicable(lastPlayer, moveLength);
                firstMoveDone = true; 
                
                if (swapApplies) {
                    const mode = document.getElementById('game-mode').value;
                    
                    if (mode === 'HvsB') {
                        // J2 (Bot) decide automaticamente e usa a troca
                        log(`J1 jogou ${moveLength} c√©lulas. Bot (J2) usa a Regra da Troca.`);
                        sidesSwapped = true;
                        swapAvailable = false;
                        swapBtn.disabled = true;
                        
                        currentPlayer = PLAYER1; // Volta para J1
                        updateStatus();
                        
                        if (getBotPlayer() === PLAYER1) {
                            makeBotMove();
                        } else {
                            renderBoard();
                        }
                        return;
                        
                    } else if (mode === 'HvsH' || mode === 'BvsH') {
                        // J2 (Humano) decide. Ativa o bot√£o e passa o turno para J2.
                        swapAvailable = true;
                        swapBtn.disabled = false;
                        
                        const player1Type = mode === 'HvsH' ? 'Humano' : 'Bot';
                        log(`J1 (${player1Type}) jogou ${moveLength} c√©lulas. JOGADOR 2 (Humano) pode optar por 'Trocar Lados' ou fazer a sua jogada.`);
                        currentPlayer = PLAYER2;
                        updateStatus();
                        renderBoard();
                        return; // O jogo espera pela decis√£o do J2
                    }
                }
                // Se a jogada do J1 for v√°lida, mas a troca n√£o se aplica (imposs√≠vel com moveLength >= 2 agora, mas mantido por seguran√ßa), 
                // continua o fluxo normal.
            } 
            
            // 2. LIMPEZA DA TROCA AP√ìS JOGADA NORMAL DE J2 (Se a troca estava dispon√≠vel e J2 jogou)
            if (swapAvailable && lastPlayer === PLAYER2) {
                 swapAvailable = false;
                 swapBtn.disabled = true;
            }
            
            // 3. VERIFICA√á√ÉO DE FIM DE JOGO (L√≥gica Mis√®re: O jogador bloqueado VENCE)
            const nextPlayer = currentPlayer === PLAYER1 ? PLAYER2 : PLAYER1;
            
            if (checkGameOver(board, nextPlayer)) {
                gameActive = false;
                
                // O VENCEDOR √â O JOGADOR QUE FICOU BLOQUEADO
                const winner = nextPlayer; 
                const loser = lastPlayer;
                
                statusEl.innerText = `FIM! Jogador ${winner} VENCEU! (J${loser} fez a √∫ltima jogada e perdeu)`;
                log(`*** JOGO TERMINADO *** Jogador ${winner} VENCEU (J${loser} fez a √∫ltima jogada e perdeu).`);
                renderBoard(); 
                return;
            }

            // 4. MUDAN√áA DE TURNO
            currentPlayer = nextPlayer;
            updateStatus();
            if (isCurrentPlayerBot()) {
                makeBotMove();
            }
        }

        function triggerSwapRule() {
            if (!firstMoveDone || sidesSwapped || !gameActive || !swapAvailable) return;
            
            // Troca os lados
            sidesSwapped = true;
            swapAvailable = false;
            swapBtn.disabled = true;
            
            const mode = document.getElementById('game-mode').value;
            const user = (mode === 'HvsH' || mode === 'BvsH') ? 'Humano (J2)' : 'Bot (J2)';
            log(`${user} usou a REGRA DA TROCA! As orienta√ß√µes foram invertidas. Turno regressa a J1.`);
            
            currentPlayer = PLAYER1; // Volta para J1
            
            updateStatus();
            renderBoard();
            if (getBotPlayer() === PLAYER1) {
                makeBotMove();
            }
        }

        function checkGameOver(currentBoard, player) {
            const possibleMoves = generateAllPossibleMoves(currentBoard, player);
            return possibleMoves.length === 0;
        }
        
        function generateAllPossibleMoves(currentBoard, player) {
            const moves = [];
            const orientation = getPlayerOrientation(player);
            const isVertical = orientation === 'Vertical';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const startIdx = coordsToIdx(r, c);
                    if (currentBoard[startIdx] !== 0) continue;¬†

                    // Dire√ß√£o Positiva
                    if (isVertical) {
                        for (let endR = r + 1; endR < ROWS; endR++) {
                            const endIdx = coordsToIdx(endR, c);
                            if (currentBoard[endIdx] !== 0) break; 
                            const length = endR - r + 1;
                            if (length >= 2) moves.push({ startIdx: startIdx, endIdx: endIdx, length: length });
                        }
                    } else {¬†
                        for (let endC = c + 1; endC < COLS; endC++) {
                            const endIdx = coordsToIdx(r, endC);
                            if (currentBoard[endIdx] !== 0) break; 
                            const length = endC - c + 1;
                            if (length >= 2) moves.push({ startIdx: startIdx, endIdx: endIdx, length: length });
                        }
                    }
                    
                    // Dire√ß√£o Negativa
                    if (isVertical) {
                        for (let endR = r - 1; endR >= 0; endR--) {
                            const endIdx = coordsToIdx(endR, c);
                            if (currentBoard[endIdx] !== 0) break; 
                            const length = r - endR + 1;
                            if (length >= 2) moves.push({ startIdx: startIdx, endIdx: endIdx, length: length });
                        }
                    } else {¬†
                        for (let endC = c - 1; endC >= 0; endC--) {
                            const endIdx = coordsToIdx(r, endC);
                            if (currentBoard[endIdx] !== 0) break; 
                            const length = c - endC + 1;
                            if (length >= 2) moves.push({ startIdx: startIdx, endIdx: endIdx, length: length });
                        }
                    }
                }
            }
            return moves;
        }

        function applyMove(currentBoard, move, player) {
            const newBoard = [...currentBoard];
            const { r: r1, c: c1 } = idxToCoords(move.startIdx);
            const { r: r2, c: c2 } = idxToCoords(move.endIdx);
            const isVertical = c1 === c2;

            if (isVertical) {
                let startR = Math.min(r1, r2);
                let endR = Math.max(r1, r2);
                for (let r = startR; r <= endR; r++) { newBoard[coordsToIdx(r, c1)] = player;
                }
            } else { 
                let startC = Math.min(c1, c2);
                let endC = Math.max(c1, c2);
                for (let c = startC; c <= endC; c++) { newBoard[coordsToIdx(r1, c)] = player;
                }
            }
            return newBoard;
        }

        function getMoveCells(move) {
             const cells = [];
            const { r: r1, c: c1 } = idxToCoords(move.startIdx);
            const { r: r2, c: c2 } = idxToCoords(move.endIdx);
            const isVertical = c1 === c2;

            if (isVertical) {
                let startR = Math.min(r1, r2);
                let endR = Math.max(r1, r2);
                for (let r = startR; r <= endR; r++) { cells.push(coordsToIdx(r, c1));
                }
            } else { 
                let startC = Math.min(c1, c2);
                let endC = Math.max(c1, c2);
                for (let c = startC; c <= endC; c++) { cells.push(coordsToIdx(r1, c));
                }
            }
            return cells;
        }
        
        function getBoardHash(currentBoard, playerToMinimize) {
            return currentBoard.join('') + playerToMinimize + (sidesSwapped ? 'S' : 'N');
        }
        
        function makeBotMove() {
            const botPlayer = getBotPlayer();
            const level = document.getElementById('difficulty').value;
            let chosenMove = null;

            if (botPlayer === 0) return;

            updateStatus(true);
            setTimeout(() => {
                
                switch (level) {
                    case 'random': chosenMove = chooseRandomMove(botPlayer); break;
                    case 'greedy': chosenMove = chooseHeuristicMove(botPlayer); break;
              
                    case 'minimax_p1':
                    case 'minimax_p2':¬†
                        const depth = difficultyDepths[level];
                        const result = findBestMove(depth, botPlayer);
                        chosenMove = result.chosenMove;
                        if (chosenMove) {
                             log(`Bot JOGOU (J${botPlayer}, Prof. ${result.depthReached}): ${chosenMove.length} c√©lulas.`)
                        }
                        break;
                }

                if (chosenMove) {
                    const moveCells = getMoveCells(chosenMove);
                    const cellElements = Array.from(boardEl.children);
                    
                    moveCells.forEach(idx => {
                        cellElements[idx].classList.add('bot-move');
                    });
                    
                    setTimeout(() => {
                        moveCells.forEach(idx => {
                            cellElements[idx].classList.remove('bot-move');
                        });
                        
                        tryMove(chosenMove.startIdx, chosenMove.endIdx);
                        afterMove(botPlayer, chosenMove.length); 
                        renderBoard();

                    }, BOT_ANIMATION_DELAY_MS);
                } else {
                    // O Bot est√° bloqueado -> VENCE (Mis√®re)
                    const winner = botPlayer;
                    log(`O BOT (J${botPlayer}) n√£o tem movimentos. Jogador ${winner} VENCEU!`);
                    gameActive = false;
                    statusEl.innerText = `FIM! Bot (J${winner}) VENCEU!`;
                    renderBoard();
                }
            }, 50);
        }

        function findBestMove(depth, botPlayer) {
            memoizationTable = {};
            const possibleMoves = generateAllPossibleMoves(board, botPlayer);
            if (possibleMoves.length === 0) return { chosenMove: null, depthReached: 0 };
            const opponent = botPlayer === PLAYER1 ? PLAYER2 : PLAYER1;
            
            let bestScore = SCORE_LOSS * 2; 
            let bestMove = possibleMoves[0];
            
            const orderedMoves = possibleMoves.sort((a, b) => b.length - a.length);

            for (const move of orderedMoves) {
                const newBoard = applyMove(board, move, botPlayer);
                const score = minimax(newBoard, depth - 1, opponent, SCORE_LOSS * 2, SCORE_WIN * 2, botPlayer);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return { chosenMove: bestMove, depthReached: depth };
        }

        function minimax(currentBoard, depth, playerToMaximize, alpha, beta, botPlayer) {
            const playerToMinimize = playerToMaximize === PLAYER1 ? PLAYER2 : PLAYER1;
            
            const hash = getBoardHash(currentBoard, playerToMinimize);
            if (memoizationTable[hash] !== undefined) {
                return memoizationTable[hash];
            }

            if (depth === 0) {
                return evaluateBoard(currentBoard, botPlayer);
            }
            
            let possibleMoves = generateAllPossibleMoves(currentBoard, playerToMaximize);
            if (possibleMoves.length === 0) {
                // CORRE√á√ÉO CR√çTICA DO MIS√àRE: O jogador que n√£o pode mover (playerToMaximize) VENCE.
                let finalScore = playerToMaximize === botPlayer ? SCORE_WIN + depth : SCORE_LOSS - depth; 
                memoizationTable[hash] = finalScore;
                return finalScore;
            }
            
            possibleMoves = possibleMoves.sort((a, b) => a.length - b.length);
            let bestEval;

            if (playerToMaximize === botPlayer) {
                // MAXIMIZAR o score (Bot quer vencer/ser bloqueado pelo advers√°rio)
                bestEval = SCORE_LOSS * 2;
                for (const move of possibleMoves) {
                    const newBoard = applyMove(currentBoard, move, botPlayer);
                    const evaluation = minimax(newBoard, depth - 1, playerToMinimize, alpha, beta, botPlayer);
                    bestEval = Math.max(bestEval, evaluation);
                    alpha = Math.max(alpha, bestEval);
                    if (beta <= alpha) break;¬†
                }
            } else {
                // MINIMIZAR o score (Oponente quer que o Bot perca/seja bloqueado por ele pr√≥prio)
                bestEval = SCORE_WIN * 2;
                for (const move of possibleMoves) {
                    const newBoard = applyMove(currentBoard, move, playerToMinimize);
                    const evaluation = minimax(newBoard, depth - 1, botPlayer, alpha, beta, botPlayer);
                    bestEval = Math.min(bestEval, evaluation);
                    beta = Math.min(beta, bestEval);
                    if (beta <= alpha) break;¬†
                }
            }
            
            memoizationTable[hash] = bestEval;
            return bestEval;
        }

        function chooseRandomMove(player) {
            const possibleMoves = generateAllPossibleMoves(board, player);
            if (possibleMoves.length > 0) {
                const randomIndex = Math.floor(Math.random() * possibleMoves.length);
                return possibleMoves[randomIndex];
            }
            return null;
        }

        function chooseHeuristicMove(player) {
            // Gulosa (Mis√®re): Tenta fazer a jogada mais pequena
            const possibleMoves = generateAllPossibleMoves(board, player);
            if (possibleMoves.length === 0) return null;
            
            possibleMoves.sort((a, b) => a.length - b.length);
            return possibleMoves[0];
        }

        function analyzeCorridors(currentBoard) {
            const results = {};
            const orientations = [
                { player: PLAYER1, orientation: getPlayerOrientation(PLAYER1) },
                { player: PLAYER2, orientation: getPlayerOrientation(PLAYER2) }
            ];
            for (const { player, orientation } of orientations) {
                let maxLength = 0;
                let numLongCorridors = 0;

                const moves = generateAllPossibleMoves(currentBoard, player);
                if (moves.length > 0) {
                    maxLength = Math.max(...moves.map(m => m.length));
                    numLongCorridors = moves.filter(m => m.length >= 3).length;
                }

                results[player] = {
                    maxLength: maxLength,
                    numLongCorridors: numLongCorridors
                };
            }
            return results;
        }
        
        function evaluateBoard(currentBoard, playerToMaximize) {
            const opponent = playerToMaximize === PLAYER1 ? PLAYER2 : PLAYER1;

            if (checkGameOver(currentBoard, opponent)) { return SCORE_WIN; }
            if (checkGameOver(currentBoard, playerToMaximize)) { return SCORE_LOSS; }

            const maxMoves = generateAllPossibleMoves(currentBoard, playerToMaximize);
            const minMoves = generateAllPossibleMoves(currentBoard, opponent);
            
            const corridorAnalysis = analyzeCorridors(currentBoard);
            const maxCorridors = corridorAnalysis[playerToMaximize];
            const minCorridors = corridorAnalysis[opponent];
            
            // O BOT (MAXIMIZADOR) quer que o oponente (MINIMIZADOR) tenha mais op√ß√µes de movimento para o bloquear (Mis√®re).

            // 1. Diferen√ßa no N√∫mero de Movimentos:
            const moveDiffScore = (minMoves.length - maxMoves.length) * 50000; 

            // 2. Controle de Corredores Longos:
            const corridorControlScore = (minCorridors.numLongCorridors - maxCorridors.numLongCorridors) * 1000;
            
            // 3. Diferen√ßa de Comprimento Total (Ponderada):
            let maxTotalLength = maxMoves.reduce((sum, move) => sum + move.length, 0);
            let minTotalLength = minMoves.reduce((sum, move) => sum + move.length, 0);
            const lengthDiffScore = (minTotalLength - maxTotalLength) * 50; 
            
            // 4. Controlo de Pe√ßas:
            let maxPieces = currentBoard.filter(p => p === playerToMaximize).length;
            let minPieces = currentBoard.filter(p => p === opponent).length;
            const pieceDiffScore = (minPieces - maxPieces) * 10; 

            let finalScore = moveDiffScore + corridorControlScore + lengthDiffScore + pieceDiffScore;
            
            return finalScore;
        }
    </script>
</body>
</html>
